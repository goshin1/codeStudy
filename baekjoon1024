n, l = map(int, input().split())
for i in range(l, 101):
    x = n - (i * (i + 1) / 2)
    if x % i == 0:
        x = int(x / i)
        if x >= -1:
            for j in range(1, i + 1): 
                print(x + j, end=' ')
            print()
            break
else:
    print(-1)
"""
n = (x + 1) + (x + 2) + (x + 3) + (x + 4) + ... + (x + l)
n = lx + l(l + 1) / 2
lx = n - l(l + 1) / 2

처음 문제를 풀 때 투포인터 문제로 생각하고 left, right를 설정해서 조건에 맞는 수열을 찾는 방법으로 구현했다.
하지만 이 방법으로 할 경우 1000000000 이하의 최대 100개의 수열을 찾아내는 것은 2초안에 해결하는 것은 무리였다.
조사결과 해당 문제는 투 포인터가 아닌 가능한 수식이 있다는 것을 알 수 있었고 위 수식이 그 수식이다.
숫자 n은 l개의 연속되는 수열의 합이다. n = (x + 1) + (x + 2) + (x + 3) + (x + 4) + ... + (x + l)
이를 수식으로 짧게 표현하면 n = lx + l(l + 1) / 2이다.
n = 10, l = 4

10 = 1 + 2 + 3 + 4
10 = 4 + 3 + 2 + 1

20 = 5 + 5 + 5 + 5 이렇게 되면 20 / 2 = (5 * 4) / 2 이다.
이 때 앞에 lx가 없어도 같기 때문에 x = 0이다.
수식에 대입하면 10 = 4 * 0 + 4 * 5 / 2 으로 같은 결과가 나온다.
x가 0이라 쉬웠던 부분이 있어 n = 12, l = 3
12 = 3 + 4 + 5
12 = 5 + 4 + 3

24 = 8 + 8 + 8
24 / 2 = 8 * 3 / 2
12 = 3 * x + 3 * 4 / 2 = 3 * x + 6 으로 x = 2 이다. 대입하면
3 * 2 + 3 * 4 / 2 = 12로 해당 식이 맞다는 것을 알 수 있다.
그리고 이를 정리하면 lx = n - l(l+1) / 2이고 정수가 나오면 해당 값이 맞다는 것이 된다.


참고 : https://hooongs.tistory.com/334
"""
